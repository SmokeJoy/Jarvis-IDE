Guida Completa a TypeScript: Da Principiante a Esperto
I. Introduzione
TypeScript si è affermato come uno strumento fondamentale nello sviluppo software moderno, estendendo JavaScript con un robusto sistema di tipi statici. Questa guida è progettata per accompagnare gli sviluppatori, dai principianti assoluti agli esperti, attraverso un percorso di apprendimento completo di TypeScript, coprendo i concetti fondamentali, le funzionalità intermedie e avanzate, le migliori pratiche e l'integrazione nell'ecosistema di sviluppo attuale.
1. Cos'è TypeScript e Perché Usarlo?
TypeScript è un superset tipizzato di JavaScript che compila in JavaScript puro. Creato e mantenuto da Microsoft, il suo scopo principale è aggiungere tipizzazione statica opzionale a JavaScript. Mentre JavaScript è un linguaggio a tipizzazione dinamica (dove i tipi vengono controllati solo a runtime), TypeScript introduce un controllo dei tipi in fase di compilazione (static typing).
I principali benefici dell'adozione di TypeScript includono:
 * Rilevamento Precoce degli Errori: Il controllo statico dei tipi permette di individuare molti errori comuni (es. errori di battitura, uso improprio di API, valori null o undefined inattesi) durante la fase di sviluppo, prima che il codice venga eseguito, riducendo significativamente i bug in produzione. Questo contrasta con JavaScript, dove tali errori emergono solo a runtime.
 * Migliore Manutenibilità e Leggibilità del Codice: Le annotazioni di tipo esplicite rendono il codice più auto-documentante, facilitando la comprensione delle strutture dati e delle firme delle funzioni. Questo è particolarmente vantaggioso in progetti su larga scala e team di sviluppo.
 * Tooling Avanzato (IntelliSense): Il sistema di tipi di TypeScript abilita funzionalità avanzate negli editor di codice come VS Code, tra cui autocompletamento più preciso, navigazione del codice (es. "Vai a definizione", "Trova riferimenti") e refactoring più sicuri.
 * Scalabilità: La struttura e la sicurezza offerte da TypeScript facilitano lo sviluppo e la manutenzione di applicazioni complesse e di grandi dimensioni.
 * Integrazione Graduale: Essendo un superset di JavaScript, TypeScript permette un'adozione incrementale. Il codice JavaScript valido è anche codice TypeScript valido, consentendo di migrare progetti esistenti gradualmente.
 * Accesso a Funzionalità JavaScript Moderne: TypeScript permette di utilizzare le ultime funzionalità di ECMAScript (ES6 e successive) e di compilarle in versioni di JavaScript compatibili con browser o ambienti più vecchi (downleveling).
2. Impostazione dell'Ambiente di Sviluppo
Per iniziare a usare TypeScript, è necessario installare il compilatore TypeScript (tsc). Il modo più comune è tramite npm (Node.js Package Manager):
npm install -g typescript

Questo comando installa tsc globalmente. È possibile verificare l'installazione con tsc --version.
Successivamente, si crea un file TypeScript (con estensione .ts, o .tsx se contiene JSX ) e si scrive il codice. Per compilare il file TypeScript in JavaScript, si usa il comando tsc:
tsc nomefile.ts

Questo genererà un file nomefile.js.
Per progetti più complessi, è fondamentale utilizzare un file tsconfig.json. Questo file specifica la root del progetto TypeScript e le opzioni del compilatore (come il target JavaScript, il sistema di moduli, le opzioni di strictness, ecc.). Si può generare un tsconfig.json di base con il comando:
tsc --init

Visual Studio Code offre un eccellente supporto integrato per TypeScript, includendo IntelliSense, type checking in tempo reale e debugging, ma non include il compilatore tsc, che deve essere installato separatamente.
II. Fondamenti di TypeScript (Principianti)
Questa sezione copre i concetti base necessari per iniziare a scrivere codice TypeScript.
1. Tipi Primitivi e Dichiarazione di Variabili
TypeScript estende i tipi primitivi di JavaScript con annotazioni di tipo statiche.
 * (a) Tipizzazione Statica vs Dinamica:
   JavaScript è dinamicamente tipizzato: i tipi delle variabili sono determinati e controllati solo a runtime. Questo offre flessibilità ma può portare a errori scoperti tardi.
   TypeScript introduce la tipizzazione statica: i tipi sono definiti e controllati durante la compilazione (prima dell'esecuzione). Questo permette di catturare errori di tipo precocemente. La tipizzazione statica migliora la robustezza e la manutenibilità del codice, specialmente in progetti complessi.
 * (b) Dichiarazione di Variabili (let, const) con Annotazioni di Tipo:
   Le variabili si dichiarano usando let (per variabili riassegnabili) o const (per costanti il cui riferimento non può essere cambiato). Si aggiunge un'annotazione di tipo dopo il nome della variabile, separata da due punti (:), per specificare esplicitamente il tipo.
   let mioNome: string = "Alice"; // Annotazione esplicita
const eta: number = 30;       // Annotazione esplicita
let completato: boolean = false;

// mioNome = 123; // Errore: Type 'number' is not assignable to type 'string'.
// eta = 31; // Errore: Cannot assign to 'eta' because it is a constant.

 * (c) Tipi Primitivi:
   TypeScript supporta i tipi primitivi fondamentali di JavaScript :
| Tipo | Descrizione | Esempio | Snippets |
|---|---|---|---|
| string | Valori testuali (racchiusi da ', ", o `) | let colore: string = "blu"; |  |
| number | Valori numerici (floating point a 64-bit, include interi e frazioni, supporta letterali binari/ottali/esa) | let decimale: number = 6; |  |
| boolean | Valori logici true o false | let finito: boolean = false; |  |
| null | Rappresenta l'assenza intenzionale di un valore oggetto | let n: null = null; |  |
| undefined | Indica che una variabile non è stata assegnata | let u: undefined = undefined; |  |
| symbol | Valori unici e immutabili, spesso usati come chiavi di proprietà oggetto (ES2015+) | let sym = Symbol("chiave"); |  |
| bigint | Numeri interi arbitrariamente grandi (ES2020+) | let grande: bigint = 100n; |  |
È importante usare i tipi primitivi in minuscolo (string, number, boolean) invece delle loro controparti in maiuscolo (String, Number, Boolean), che si riferiscono a tipi speciali incorporati raramente usati nel codice standard.
 * (d) Inferenza dei Tipi:
   In molti casi, TypeScript può inferire automaticamente il tipo di una variabile basandosi sul valore con cui viene inizializzata. Questo riduce la necessità di annotazioni esplicite, rendendo il codice più conciso.
   let mioMessaggio = "Ciao Mondo"; // TypeScript inferisce string
const mioNumero = 42;           // TypeScript inferisce number (o 42 se const)
let attivo = true;              // TypeScript inferisce boolean

   L'inferenza avviene all'inizializzazione di variabili e membri, nell'impostazione dei valori predefiniti dei parametri e nella determinazione dei tipi restituiti dalle funzioni. Quando si usa let, il tipo inferito è generalmente il tipo primitivo più ampio (es. string), mentre con const e un valore primitivo, TypeScript inferisce un tipo letterale più specifico (es. "Ciao Mondo"). L'inferenza si applica anche a tipi più complessi come array e oggetti. Se TypeScript non riesce a inferire un tipo (es. una variabile dichiarata senza inizializzazione), di default assume il tipo any, a meno che l'opzione noImplicitAny non sia abilitata.
 * (e) any vs unknown:
   TypeScript fornisce due tipi speciali per gestire valori di cui non si conosce il tipo: any e unknown.
   * any: Rappresenta un "opt-out" dal sistema di tipi. Una variabile di tipo any può contenere qualsiasi valore, e si possono eseguire su di essa qualsiasi operazione (accesso a proprietà, chiamate di funzioni) senza che il compilatore segnali errori, anche se tali operazioni non sono valide a runtime. L'uso di any compromette la sicurezza dei tipi ed è generalmente sconsigliato, tranne in casi specifici come la migrazione graduale da JavaScript o l'interazione con librerie non tipizzate.
     let variabileAny: any = 4;
variabileAny.toFixed(2); // OK a compile-time, ma potrebbe fallire a runtime se non è un numero
variabileAny = "testo";
variabileAny.nonEsiste(); // OK a compile-time, errore a runtime

   * unknown: Introdotto in TypeScript 3.0, unknown è l'alternativa type-safe ad any. Come any, una variabile unknown può contenere qualsiasi valore. Tuttavia, a differenza di any, TypeScript non permette di eseguire operazioni su un valore unknown finché il suo tipo non viene ristretto (narrowed) a uno più specifico tramite controlli di tipo (type guards come typeof, instanceof) o asserzioni di tipo (as).
     let variabileUnknown: unknown = 4;
// variabileUnknown.toFixed(2); // Errore: Object is of type 'unknown'.

if (typeof variabileUnknown === 'number') {
  variabileUnknown.toFixed(2); // OK: TypeScript sa che è un number qui
}

let altraVariabile: string = variabileAny; // OK
// let altraVariabile2: string = variabileUnknown; // Errore: Type 'unknown' is not assignable to type 'string'.

   Best Practice: Preferire unknown ad any quando si lavora con valori di tipo incerto. unknown forza il controllo del tipo prima dell'uso, mantenendo la sicurezza dei tipi, mentre any la elude.
| Caratteristica | any | unknown | Snippets |
|---|---|---|---|
| Type Checking | Disabilitato | Abilitato (richiede narrowing/asserzione) |  |
| Assegnabilità | Assegnabile a/da qualsiasi tipo | Assegnabile da qualsiasi tipo, a any/unknown solo |  |
| Operazioni | Qualsiasi operazione permessa | Nessuna operazione permessa senza narrowing |  |
| Sicurezza Tipi | Bassa | Alta |  |
| Uso | Da evitare, migrazione JS, librerie non tip. | Valori incerti, API esterne, input utente |  |
 * (f) type vs interface:
   Sia type (type alias) che interface permettono di definire la "forma" (shape) di oggetti e tipi complessi.
   // Usando interface
interface PointInterface {
  x: number;
  y: number;
}

// Usando type alias
type PointType = {
  x: number;
  y: number;
};

   Differenze Chiave:
   * Estendibilità/Declaration Merging:
     * interface: Le interfacce con lo stesso nome nello stesso scope vengono unite (declaration merging). Questo permette di estendere interfacce (anche da librerie terze) aggiungendo nuove proprietà. Le interfacce possono estendere altre interfacce (o tipi oggetto) usando extends.
     * type: I type alias non possono essere riaperti per aggiungere proprietà (no declaration merging). Per combinare tipi si usano gli operatori di unione (|) o intersezione (&).
   * Tipi Primitivi, Unioni, Tuple:
     * interface: Principalmente usate per descrivere la forma di oggetti o, in alcuni casi, funzioni. Non possono definire alias per tipi primitivi, unioni o tuple direttamente.
     * type: Più versatili, possono definire alias per qualsiasi tipo, inclusi primitivi, unioni, intersezioni, tuple, tipi mappati, tipi condizionali, ecc..
   * Implementazione da Classi (implements):
     * Le classi possono usare implements sia con interface che con type (che definiscono una forma oggetto) per verificare la conformità strutturale. Tuttavia, una classe non può implementare un type alias che rappresenta un tipo unione.
   * Performance e Messaggi di Errore:
     * Le interfacce possono offrire performance leggermente migliori in scenari complessi di ereditarietà a causa del caching interno di TypeScript. A volte forniscono messaggi di errore più chiari rispetto ai type alias complessi.
   Quando Usare Cosa (Best Practice):
   * Usa interface: Per definire la forma di oggetti, specialmente se prevedi di estenderli (ereditarietà OOP) o se necessiti di declaration merging (es. per aumentare tipi da librerie). È la scelta tradizionale per le forme oggetto e i contratti di classe.
   * Usa type: Per definire alias per tipi primitivi, unioni, intersezioni, tuple, tipi funzione (spesso più leggibile), tipi mappati, tipi condizionali, o quando non necessiti delle caratteristiche specifiche delle interfacce. Alcune guide stilistiche suggeriscono di usare type di default per la sua maggiore flessibilità e minore "sorpresa" (declaration merging può essere inatteso).
   * Consistenza: Scegli uno stile (preferire interface per oggetti o preferire type in generale) e mantienilo coerente nel progetto.
| Caratteristica | interface | type | Snippets |
|---|---|---|---|
| Scopo Primario | Definire forme oggetto, contratti di classe | Definire alias per qualsiasi tipo |  |
| Declaration Merging | Sì | No |  |
| Estensione | extends | & (intersezione) |  |
| Implementazione | implements (da classi) | implements (da classi, se forma oggetto) |  |
| Tipi Primitivi | No | Sì |  |
| Unioni/Intersezioni | No (direttamente) | Sì (` | , &`) |
| Tuple | No | Sì |  |
| Tipi Mappati | No | Sì |  |
| Raccomandazione | Oggetti, ereditarietà, merging, contratti classe | Primitivi, unioni, tuple, tipi funzione, tipi mappati, maggiore flessibilità |  |
 * (g) Proprietà Opzionali (?) e readonly:
   * Proprietà Opzionali (?): Si possono definire proprietà che potrebbero non essere presenti in un oggetto aggiungendo un ? dopo il nome della proprietà nella definizione del tipo o dell'interfaccia. Quando si accede a una proprietà opzionale, TypeScript la considera come potenzialmente undefined, richiedendo spesso un controllo prima dell'uso (es. if (obj.prop) {...} o obj.prop?.metodo()).
     interface PaintOptions {
  shape: Shape;
  xPos?: number; // xPos è opzionale
  yPos?: number; // yPos è opzionale
}

   * Proprietà readonly: Si possono marcare le proprietà come di sola lettura usando il modificatore readonly prima del nome della proprietà. Una proprietà readonly può essere assegnata solo durante l'inizializzazione dell'oggetto o nel costruttore della classe. Qualsiasi tentativo successivo di riassegnazione genererà un errore in fase di compilazione. readonly promuove l'immutabilità , ma è importante notare che è un controllo a livello di compilazione e non impedisce la mutazione di oggetti interni se la proprietà stessa è un riferimento a un oggetto. readonly differisce da const: readonly si applica alle proprietà degli oggetti, mentre const si applica alle dichiarazioni di variabili.
     interface Punto {
  readonly x: number;
  readonly y: number;
}
let p1: Punto = { x: 10, y: 20 };
// p1.x = 5; // Errore: Cannot assign to 'x' because it is a read-only property.

 * (i) Opzione strict del Compilatore e Sotto-opzioni:
   L'opzione strict: true nel file tsconfig.json abilita un insieme di controlli di tipo più rigorosi, migliorando notevolmente la robustezza e la correttezza del codice. Abilitare strict è una best practice raccomandata per nuovi progetti. Equivale ad abilitare tutte le opzioni della "strict mode family". È possibile abilitare strict: true e poi disabilitare selettivamente alcune sotto-opzioni se necessario.
   Le principali sotto-opzioni abilitate da strict: true includono:
   * noImplicitAny: Segnala un errore quando TypeScript non può inferire un tipo e implicitamente lo deduce come any (es. parametri di funzione non annotati). Forza l'annotazione esplicita dei tipi in questi casi.
   * strictNullChecks: Tratta null e undefined come tipi distinti e non assegnabili alla maggior parte degli altri tipi per default. Richiede di gestire esplicitamente la possibilità che un valore sia null o undefined (es. usando union types T | null o controlli).
   * strictFunctionTypes: Abilita un controllo più rigoroso sulla covarianza e controvarianza dei parametri delle funzioni, prevenendo assegnazioni di funzioni potenzialmente non sicure.
   * strictBindCallApply: Applica una verifica più stringente sui metodi bind, call, e apply delle funzioni, assicurando che gli argomenti passati siano compatibili con la funzione target.
   * strictPropertyInitialization: Verifica che le proprietà delle classi (non definite come undefined nel costruttore) siano inizializzate nel costruttore o abbiano un inizializzatore di proprietà. Richiede strictNullChecks abilitato.
   * noImplicitThis: Segnala un errore quando this viene usato in un contesto dove il suo tipo sarebbe implicitamente any.
   * alwaysStrict: Assicura che il codice sia analizzato in modalità strict JavaScript e aggiunge "use strict"; all'output JavaScript generato.
   * useUnknownInCatchVariables (da TS 4.4, abilitata da strict): Fa sì che la variabile nell'istruzione catch sia di tipo unknown invece di any, forzando controlli di tipo sull'errore catturato.
III. Concetti Intermedi di TypeScript
Questa sezione approfondisce funzionalità più complesse ma fondamentali per scrivere codice TypeScript efficace e scalabile.
1. Funzioni in Dettaglio
TypeScript offre un controllo granulare sulla definizione e l'uso delle funzioni.
 * (a) Annotazioni di Tipo per Parametri e Valori di Ritorno:
   Come visto nei fondamenti, è possibile (e spesso raccomandato) annotare i tipi dei parametri e il tipo del valore di ritorno di una funzione.
   function moltiplica(a: number, b: number): number {
  return a * b;
}

   Se il tipo di ritorno non è annotato, TypeScript cercherà di inferirlo analizzando le istruzioni return. Per funzioni che non restituiscono un valore, si usa void. Per funzioni asincrone che restituiscono una Promise, si annota il tipo restituito come Promise<T> dove T è il tipo del valore risolto.
 * (b) Tipi Funzione (Function Types):
   È possibile definire un tipo che descrive la firma di una funzione, specificando i tipi dei parametri e il tipo di ritorno. Questo è utile per assegnare funzioni a variabili o passarle come argomenti. La sintassi assomiglia a quella delle arrow function.
   type OperazioneMatematica = (x: number, y: number) => number;

let aggiungi: OperazioneMatematica = (a, b) => a + b;
let sottrai: OperazioneMatematica = (a, b) => a - b;

// let errata: OperazioneMatematica = (a: string) => a; // Errore

   Nei tipi funzione, i nomi dei parametri sono richiesti per la leggibilità ma non influenzano la compatibilità del tipo; solo i tipi dei parametri e il tipo di ritorno sono rilevanti.
 * (c) Arrow Functions:
   TypeScript supporta pienamente la sintassi delle arrow function di ES6 (=>), che offrono una sintassi più concisa per le espressioni di funzione e catturano lessicalmente il valore di this dal contesto circostante.
   const quadrati =.[span_0](start_span)[span_0](end_span)[span_1](start_span)[span_1](end_span)[span_2](start_span)[span_2](end_span)map((n: number): number => n * n);

 * (d) Parametri Opzionali e Predefiniti:
   * Opzionali (?): Un parametro può essere reso opzionale aggiungendo ? dopo il suo nome. I parametri opzionali devono seguire quelli richiesti. Il tipo di un parametro opzionale è implicitamente un'unione con undefined.
     function saluta(nome: string, titolo?: string) {
  return `Ciao ${titolo? titolo + ' ' : ''}${nome}`;
}
saluta("Mario"); // OK
saluta("Luigi", "Sig."); // OK

   * Predefiniti: Si può assegnare un valore predefinito a un parametro usando =. Se l'argomento non viene fornito o è undefined, viene usato il valore predefinito. I parametri predefiniti non devono necessariamente seguire quelli richiesti, ma se precedono un parametro richiesto, è necessario passare undefined esplicitamente per usare il default.
     function creaSaluto(nome: string, saluto: string = "Ciao") {
  return `${saluto}, ${nome}!`;
}
creaSaluto("Anna"); // "Ciao, Anna!"
creaSaluto("Marco", "Buongiorno"); // "Buongiorno, Marco!"

 * (e) Parametri Rest (...):
   Permettono a una funzione di accettare un numero indefinito di argomenti come un array. Il parametro rest deve essere l'ultimo nella lista dei parametri e deve essere di tipo array.
   function sommaTutto(...numeri: number): number {
  return numeri.reduce((sum, current) => sum + current, 0);
}
sommaTutto(1, 2, 3); // 6
sommaTutto(10, 20); // 30

 * (f) this nelle Funzioni:
   Il comportamento di this in JavaScript può essere fonte di confusione. Le arrow function (=>) catturano il this dal contesto lessicale in cui sono definite, risolvendo molti problemi comuni. TypeScript permette anche di specificare esplicitamente il tipo atteso per this come primo parametro (fittizio) nella definizione di una funzione o metodo. Questo non modifica il JavaScript generato ma fornisce controllo di tipo in fase di compilazione.
   interface Calcolatrice {
  valoreCorrente: number;
  aggiungi(this: Calcolatrice, operando: number): void;
}

let calc: Calcolatrice = {
  valoreCorrente: 0,
  aggiungi(operando: number) {
    this.valoreCorrente += operando;
  }
};

// calc.aggiungi(5); // OK

// let standaloneAggiungi = calc.aggiungi;
// standaloneAggiungi(10); // Errore: 'this' context of type 'void' is not assignable to method's 'this' of type 'Calcolatrice'.

   Usare this: void indica che una funzione non dovrebbe usare this.
 * (g) Overload di Funzioni (Function Overloads):
   Permettono di definire firme multiple per la stessa funzione, specificando diversi tipi di parametri e/o tipi di ritorno. Si elencano le firme di overload e poi si fornisce un'unica implementazione compatibile con tutte le firme. L'implementazione spesso usa controlli di tipo (typeof, instanceof) per gestire i diversi casi. Il compilatore sceglie la prima firma di overload che corrisponde alla chiamata. È importante ordinare le firme dalla più specifica alla più generale.
   // Firme di overload
function creaData(timestamp: number): Date;
function creaData(giorno: number, mese: number, anno: number): Date;

// Implementazione (deve essere compatibile con entrambe le firme)
function creaData(arg1: number, arg2?: number, arg3?: number): Date {
  if (arg2!== undefined && arg3!== undefined) {
    return new Date(arg3, arg2 - 1, arg1); // Anno, Mese (0-based), Giorno
  } else {
    return new Date(arg1); // Timestamp
  }
}

const d1 = creaData(1678886400000); // Usa la prima firma
const d2 = creaData(15, 3, 2025);   // Usa la seconda firma

   
   L'overload in TypeScript riguarda le firme, non l'implementazione; c'è sempre un solo corpo di funzione. Spesso, parametri opzionali o tipi unione sono alternative preferibili a overload complessi.
2. Classi in TypeScript
TypeScript estende le classi JavaScript ES6 con funzionalità aggiuntive come modificatori di accesso e interfacce.
 * (a) Sintassi Base, Campi, Costruttori, Metodi:
   La sintassi è simile a ES6. Si usa la parola chiave class.
   * Campi (Fields/Properties): Dichiarati all'interno della classe, opzionalmente con tipo e valore iniziale.
   * Costruttore (Constructor): Metodo speciale constructor per inizializzare gli oggetti. Può avere parametri.
   * Metodi (Methods): Funzioni definite all'interno della classe.
   class Saluto {
  messaggio: string; // Campo

  constructor(msg: string) { // Costruttore
    this.messaggio = msg;
  }

  saluta(): string { // Metodo
    return "Ciao, " + this.messaggio;
  }
}

let salutoIstanza = new Saluto("mondo");
console.log(salutoIstanza.saluta()); // "Ciao, mondo"

 * (b) Ereditarietà (extends, super()):
   Le classi possono ereditare da altre classi usando extends. La classe derivata (sottoclasse) eredita proprietà e metodi dalla classe base (superclasse). La sottoclasse può aggiungere nuovi membri o sovrascrivere quelli ereditati. Se la sottoclasse ha un costruttore, deve chiamare super() come prima istruzione per eseguire il costruttore della classe base.
   class Animale {
  nome: string;
  constructor(nome: string) { this.nome = nome; }
  muovi(distanza: number = 0) {
    console.log(`${this.nome} si è mosso di ${distanza}m.`);
  }
}

class Cane extends Animale {
  constructor(nome: string) {
    super(nome); // Chiama il costruttore di Animale
  }
  abbaia() {
    console.log("Bau! Bau!");
  }
  muovi(distanza: number = 5) { // Sovrascrive muovi
    console.log("Scodinzolando...");
    super.muovi(distanza); // Chiama il metodo muovi della classe base
  }
}

const fido = new Cane("Fido");
fido.abbaia();
fido.muovi(10);

 * (c) Modificatori di Accesso (public, private, protected):
   Controllano la visibilità dei membri della classe.
   * public (default): Accessibile ovunque.
   * private: Accessibile solo all'interno della classe stessa in cui è dichiarato. TypeScript ha anche i campi privati ECMAScript (#nomeCampo) che forniscono un'incapsulamento più forte a runtime. La private di TypeScript è solo un controllo in fase di compilazione.
   * protected: Accessibile all'interno della classe dichiarante e delle sue sottoclassi.
   class Persona {
  public nome: string;
  private segreto: string;
  protected eta: number;

  constructor(nome: string, segreto: string, eta: number) {
    this.nome = nome;
    this.segreto = segreto;
    this.eta = eta;
  }

  mostraSegreto() {
    console.log(this.segreto); // OK
  }
}

class Impiegato extends Persona {
  constructor(nome: string, segreto: string, eta: number) {
    super(nome, segreto, eta);
  }
  mostraEta() {
    console.log(this.eta); // OK (protected)
    // console.log(this.segreto); // Errore (private)
  }
}

const p = new Persona("Mario", "abc", 40);
console.log(p.nome); // OK (public)
// console.log(p.segreto); // Errore (private)
// console.log(p.eta); // Errore (protected)
p.mostraSegreto(); // OK

const e = new Impiegato("Luigi", "xyz", 35);
e.mostraEta(); // OK

   
   I modificatori di accesso possono essere usati anche sui parametri del costruttore (parameter properties) come scorciatoia per dichiarare e inizializzare membri.
 * (d) Membri Statici (static):
   Proprietà o metodi che appartengono alla classe stessa, non a istanze specifiche. Si accedono usando il nome della classe.
   class Calcolatrice {
  static PI: number = 3.14159;
  static somma(a: number, b: number): number {
    return a + b;
  }
}
console.log(Calcolatrice.PI);
console.log(Calcolatrice.somma(5, 3));

 * (e) Implementazione di Interfacce (implements):
   Una classe può dichiarare di implementare una o più interfacce usando la parola chiave implements. Questo forza la classe a fornire un'implementazione per tutti i membri definiti nell'interfaccia, garantendo la conformità strutturale. L'implements controlla solo la parte istanza della classe. È importante capire che implements è un controllo puramente in fase di compilazione sulla struttura della classe; non modifica il tipo della classe né fornisce implementazioni.
   interface OrologioInterface {
  oraCorrente: Date;
  impostaOra(d: Date): void;
}

class OrologioDigitale implements OrologioInterface {
  oraCorrente: Date = new Date();
  impostaOra(d: Date) {
    this.oraCorrente = d;
  }
  constructor(h: number, m: number) { /*... */ }
}

 * (f) Classi Astratte (abstract):
   Le classi astratte servono come classi base da cui altre classi possono derivare. Non possono essere istanziate direttamente. Possono contenere membri astratti (metodi o proprietà dichiarati senza implementazione usando abstract) che devono essere implementati dalle classi derivate concrete.
   abstract class Dipartimento {
  constructor(public nome: string) {}

  stampaNome(): void {
    console.log("Nome Dipartimento: " + this.nome);
  }

  abstract stampaMeeting(): void; // Metodo astratto
}

class DipartimentoContabile extends Dipartimento {
  constructor() {
    super("Contabilità e Auditing"); // I costruttori nelle classi derivate devono chiamare super()
  }

  stampaMeeting(): void { // Implementazione del metodo astratto
    console.log("Il Dipartimento Contabile si riunisce ogni lunedì alle 10");
  }

  generaReport(): void {
    console.log("Generazione report contabile...");
  }
}

// let dipartimento: Dipartimento; // OK: creare un riferimento a un tipo astratto
// dipartimento = new Dipartimento(); // Errore: non si può creare un'istanza di una classe astratta
let dipartimento: Dipartimento = new DipartimentoContabile(); // OK: creare e assegnare un'istanza di una sottoclasse
dipartimento.stampaNome();
dipartimento.stampaMeeting();
// dipartimento.generaReport(); // Errore: il metodo non esiste sul tipo 'Dipartimento'

3. Generics (<T>)
I Generics sono uno strumento potente per creare componenti riutilizzabili che possono lavorare con una varietà di tipi mantenendo la sicurezza del tipo.
 * (a) Sintassi e Benefici:
   Si introduce un parametro di tipo (spesso T, ma può essere qualsiasi identificatore valido) usando parentesi angolari <>. Questo parametro agisce come un segnaposto per un tipo che verrà specificato quando il componente generico viene utilizzato. I benefici principali sono la riutilizzabilità del codice e la sicurezza dei tipi (type safety).
   // Funzione generica 'identity'
function identity<Type>(arg: Type): Type {
  return arg;
}

let outputString = identity<string>("myString"); // Type è string
let outputNumber = identity<number>(100);       // Type è number
let inferredOutput = identity("autoInfer");     // Type è inferito come string

 * (b) Generics in Funzioni, Classi, Interfacce:
   I generics possono essere usati in:
   * Funzioni: Per creare funzioni che operano su tipi diversi ma correlati.
   * Classi: Per creare classi che possono gestire membri di tipi diversi.
   * Interfacce: Per definire contratti generici.
   // Interfaccia Generica
interface Coppia<K, V> {
  chiave: K;
  valore: V;
}
let coppiaNumStr: Coppia<number, string> = { chiave: 1, valore: "uno" };

// Classe Generica
class Contenitore<Type> {
  private contenuto: Type;
  constructor(val: Type) { this.contenuto = val; }
  getValore(): Type { return this.contenuto; }
}
let contenitoreString = new Contenitore<string>("testo");
let contenitoreNum = new Contenitore(123); // Inferenza del tipo

 * (c) Vincoli Generici (extends, keyof):
   Spesso è necessario limitare i tipi che possono essere usati come parametri generici.
   * extends: Si usa extends per vincolare il parametro di tipo a sottotipi di un altro tipo o a tipi che soddisfano una certa interfaccia. Questo permette di usare proprietà o metodi del tipo vincolante in modo sicuro all'interno del componente generico. Un errore comune è tentare di accedere a membri di un tipo generico non vincolato.
     interface ConLunghezza {
  length: number;
}
// Vincola Type ad avere una proprietà 'length'
function logLunghezza<Type extends ConLunghezza>(arg: Type): void {
  console.log(arg.length); // OK perché Type ha 'length'
}
logLunghezza("hello"); // OK (string ha length)
logLunghezza([span_3](start_span)[span_3](end_span)[span_4](start_span)[span_4](end_span));  // OK (array ha length)
// logLunghezza(3); // Errore: number non ha 'length'

   * keyof: Usato con extends, permette di vincolare un parametro di tipo a essere una delle chiavi (nomi di proprietà) di un altro tipo.
     function getProprieta<Type, Key extends keyof Type>(obj: Type, key: Key) {
  return obj[key];
}
let x = { a: 1, b: "ciao", c: true };
getProprieta(x, "a"); // OK, restituisce number
getProprieta(x, "b"); // OK, restituisce string
// getProprieta(x, "d"); // Errore: "d" non è una chiave di x

 * (d) Usare Tipi di Classe nei Generics:
   È possibile usare i tipi di classe (costruttori) come parametri generici, utile per pattern come le factory.
   function creaIstanza<Type>(costruttore: { new (): Type }): Type {
  return new costruttore();
}

class MiaClasse {
  valore: number = 10;
}
let istanza = creaIstanza(MiaClasse);
console.log(istanza.valore); // 10

IV. Tipi Avanzati e Funzionalità Esperte
Questa sezione esplora le potenti funzionalità del sistema di tipi di TypeScript per modellare scenari complessi.
1. Tipi Mappati (Mapped Types)
I tipi mappati permettono di creare nuovi tipi trasformando le proprietà di un tipo esistente. Si basano sulla sintassi degli index signature ([key: string]: type) ma usano in keyof per iterare sulle chiavi di un tipo esistente.
 * (a) Definizione e Sintassi:
   La sintassi base è {[P in K]: T}, dove K è un union type di chiavi (spesso keyof Type) e P itera su ciascuna chiave.
   type SoloBooleani<Type> = {
 : boolean; // Mappa ogni proprietà a boolean
};

interface Opzioni {
  opzione1: string;
  opzione2: number;
}

type FlagOpzioni = SoloBooleani<Opzioni>;
// Equivale a: { opzione1: boolean; opzione2: boolean; }

 * (b) Modificatori (readonly, ?) con +/-:
   È possibile aggiungere o rimuovere i modificatori readonly e ? (opzionale) durante la mappatura usando i prefissi + (default) o -.
   // Rende tutte le proprietà scrivibili (rimuove readonly)
type Mutable<Type> = {
  -readonly: Type[Proprieta];
};

// Rende tutte le proprietà richieste (rimuove?)
type Concrete<Type> = {
 -?: Type[Proprieta];
};

// Rende tutte le proprietà opzionali (aggiunge?)
type Partial<Type> = {
 ?: Type[Proprieta];
};

// Rende tutte le proprietà readonly (aggiunge readonly)
type Readonly<Type> = {
  readonly: Type[Proprieta];
};

   Questi sono alla base dei tipi di utilità integrati come Partial<T>, Required<T>, Readonly<T>.
 * (c) Key Remapping con as:
   Da TypeScript 4.1, è possibile rinominare le chiavi durante la mappatura usando la clausola as. Questo permette trasformazioni potenti, spesso combinate con template literal types o conditional types per filtrare o modificare i nomi delle chiavi.
   // Aggiunge 'get' come prefisso e capitalizza il nome della proprietà
type Getters<Type> = {
 : () => Type[Proprieta]
};

interface Persona { nome: string; eta: number; }
type GettersPersona = Getters<Persona>;
// Equivale a: { getNome: () => string; getEta: () => number; }

// Filtra le chiavi, rimuovendo 'kind'
type RimuoviKind<Type> = {
 : Type[Proprieta]
};

interface Cerchio { kind: "cerchio"; raggio: number; }
type CerchioSenzaKind = RimuoviKind<Cerchio>;
// Equivale a: { raggio: number; }

   
   La capacità di filtrare chiavi producendo never nella clausola as (come nell'esempio RimuoviKind) è una tecnica particolarmente potente per derivare tipi con forme precise.
2. Tipi Condizionali (Conditional Types)
I tipi condizionali permettono di scegliere un tipo basandosi su una condizione che coinvolge altri tipi. La sintassi assomiglia all'operatore ternario di JavaScript.
 * (a) Sintassi (extends? TrueType : FalseType):
   La forma base è CheckType extends ExtendsType? TrueType : FalseType. Se CheckType è assegnabile a ExtendsType, il risultato è TrueType, altrimenti è FalseType.
   interface IdLabel { id: number; }
interface NameLabel { name: string; }

type LabelType<T extends number | string> =
  T extends number? IdLabel : NameLabel;

let label1: LabelType<number>; // label1 è di tipo IdLabel
let label2: LabelType<string>; // label2 è di tipo NameLabel

 * (b) Inferenza con infer:
   La parola chiave infer può essere usata all'interno della clausola extends di un tipo condizionale per dichiarare una variabile di tipo da inferire. Se la condizione è soddisfatta, il tipo inferito può essere usato nel ramo "true". Questo è fondamentale per estrarre tipi da strutture complesse (es. tipi restituiti da funzioni, tipi di elementi di array, tipi risolti da Promise).
   // Estrae il tipo degli elementi di un array
type Flatten<T> = T extends Array<infer Item>? Item : T;
type Str = Flatten<string>; // Str è string
type Num = Flatten<number>;   // Num è number (non è un array, quindi restituisce T)

// Estrae il tipo di ritorno di una funzione
type GetReturnType<Type> = Type extends (...args: any) => infer Return? Return : never;
type NumRet = GetReturnType<() => number>; // NumRet è number
type StrRet = GetReturnType<(s: string) => string>; // StrRet è string

   
   Quando si inferisce da tipi con firme multiple (es. funzioni sovraccaricate), viene usata l'ultima firma (generalmente la più permissiva).
 * (c) Tipi Condizionali Distributivi:
   Quando un tipo condizionale agisce su un parametro di tipo generico "nudo" (es. T extends U?...) e a quel parametro viene passato un tipo unione, il tipo condizionale viene applicato a ciascun membro dell'unione separatamente, e i risultati vengono riuniti in una nuova unione.
   type ToArray<Type> = Type extends any? Type : never;
type StrArrOrNumArr = ToArray<string | number>;
// StrArrOrNumArr è string | number
// (Equivale a ToArray<string> | ToArray<number>)

   
   Questo comportamento distributivo è spesso desiderato. Per evitarlo, si possono racchiudere entrambi i lati di extends tra parentesi quadre.
   type ToArrayNonDist<Type> = extends [any]? Type : never;
type ArrOfStrOrNum = ToArrayNonDist<string | number>;
// ArrOfStrOrNum è (string | number)

3. Discriminated Unions (Tagged Unions)
Questo è un pattern molto efficace per modellare tipi che possono assumere diverse forme varianti in modo sicuro.
 * (a) Definizione: Si crea un'unione di tipi oggetto, dove ogni tipo nell'unione condivide una proprietà comune (il discriminante o tag). Il valore di questa proprietà è un tipo letterale (stringa o numero) unico per ciascun tipo nell'unione.
   interface Quadrato {
  kind: "quadrato"; // Discriminante
  lato: number;
}
interface Rettangolo {
  kind: "rettangolo"; // Discriminante
  larghezza: number;
  altezza: number;
}
interface Cerchio {
  kind: "cerchio"; // Discriminante
  raggio: number;
}

type Forma = Quadrato | Rettangolo | Cerchio; // Discriminated Union

 * (b) Narrowing e Type Safety: Il discriminante permette a TypeScript di restringere (narrow) il tipo dell'unione all'interno di blocchi condizionali (if, switch) basati sul valore del discriminante. Questo rende l'accesso alle proprietà specifiche di ciascuna variante sicuro.
   function calcolaArea(s: Forma): number {
  switch (s.kind) {
    case "quadrato":
      // Qui TypeScript sa che 's' è di tipo Quadrato
      return s.lato * s.lato;
    case "rettangolo":
      // Qui TypeScript sa che 's' è di tipo Rettangolo
      return s.larghezza * s.altezza;
    case "cerchio":
      // Qui TypeScript sa che 's' è di tipo Cerchio
      return Math.PI * s.raggio ** 2;
    default:
      // Utile per exhaustiveness checking
      const _checkNever: never = s;
      return _checkNever;
  }
}

   
   L'uso di switch con un default che assegna a never garantisce l'exhaustiveness checking: se si aggiunge un nuovo tipo all'unione Forma senza aggiornare lo switch, il compilatore segnalerà un errore. Questo pattern rende il codice che gestisce varianti di dati molto più robusto e manutenibile rispetto ad alternative meno sicure.
4. Type Guards
I Type Guards sono espressioni runtime che restituiscono un booleano e informano il compilatore TypeScript sul tipo di un valore all'interno di un blocco di codice condizionale, permettendo il narrowing.
 * (a) typeof: Controlla il tipo primitivo di una variabile ("string", "number", "boolean", "symbol", "undefined", "object", "function", "bigint").
   function stampaLunghezza(x: string | number) {
  if (typeof x === "string") {
    console.log(x.length); // x è string qui
  } else {
    console.log(x.toFixed(2)); // x è number qui
  }
}

 * (b) instanceof: Controlla se un oggetto è un'istanza di una specifica classe o funzione costruttore, verificando la catena dei prototipi.
   class Pesce { swim() {} }
class Uccello { fly() {} }
function muoviAnimale(animale: Pesce | Uccello) {
  if (animale instanceof Pesce) {
    animale.swim(); // animale è Pesce qui
  } else {
    animale.fly(); // animale è Uccello qui
  }
}

 * (c) Operatore in: Controlla se una proprietà esiste (direttamente o nella catena dei prototipi) su un oggetto. Utile per differenziare tipi in un'unione basati sulla presenza di proprietà specifiche.
   interface Auto { guida(): void; }
interface Bici { pedala(): void; }
function usaVeicolo(v: Auto | Bici) {
  if ("guida" in v) {
    v.guida(); // v è Auto qui
  } else {
    v.pedala(); // v è Bici qui
  }
}

 * (d) Funzioni Type Guard Personalizzate (is): Si definisce una funzione che restituisce un type predicate nella forma parametro is Tipo. Se la funzione restituisce true, TypeScript restringe il tipo del parametro a Tipo nel blocco condizionale chiamante. Questo permette di incapsulare logiche di controllo complesse in funzioni riutilizzabili che forniscono sicurezza al compilatore.
   interface Gatto { miagola(): void; }
interface Cane { abbaia(): void; }

// Type guard personalizzato
function èGatto(animale: Gatto | Cane): animale is Gatto {
  return typeof (animale as Gatto).miagola === 'function';
}

function faiVerso(animale: Gatto | Cane) {
  if (èGatto(animale)) {
    animale.miagola(); // animale è Gatto qui
  } else {
    animale.abbaia(); // animale è Cane qui
  }
}

   
   I type guard sono fondamentali per lavorare con tipi unknown e tipi unione in modo sicuro, collegando la validazione runtime con l'analisi statica del compilatore.
5. Tuple ed Enum
 * (a) Tuple: Rappresentano array con una lunghezza fissa e tipi noti per ogni posizione. Sono utili per rappresentare strutture come coppie chiave-valore, coordinate o valori restituiti multipli da una funzione.
   // Tupla [string, number]
let utente: [string, number];
utente = ["Mario", 30]; // OK
// utente = [30, "Mario"]; // Errore
console.log(utente.substring(1)); // OK, utente è string
// console.log(utente.[span_5](start_span)[span_5](end_span)substring(1)); // Errore, utente[span_6](start_span)[span_6](end_span) è number

   
   TypeScript supporta elementi opzionali (?) e rest (...) nelle tuple, offrendo maggiore flessibilità. Da TS 4.0, le tuple possono avere etichette per migliorare la leggibilità.
 * (b) Enum: Permettono di definire un set di costanti nominate, rendendo il codice più leggibile rispetto all'uso di valori numerici o stringhe "magiche".
   * Numeric Enums: Associano nomi a valori numerici. Di default, iniziano da 0 e si auto-incrementano, ma i valori possono essere specificati manualmente. Generano un oggetto runtime con mapping inverso (da valore a nome).
     enum Direzione { Su, Giu, Sinistra, Destra } // 0, 1, 2, 3
enum Risposta { No = 0, Si = 1 }
let dir: Direzione = Direzione.Su;
console.log(Direzione); // "Su" (reverse mapping)

   * String Enums: Associano nomi a valori stringa. Ogni membro deve essere inizializzato esplicitamente. Non hanno mapping inverso ma offrono maggiore leggibilità nel codice JavaScript generato.
     enum LivelloLog { Errore = "ERROR", Warn = "WARN", Info = "INFO" }
let livello: LivelloLog = LivelloLog.Errore; // "ERROR"

   * Heterogeneous Enums: Permettono di mischiare membri numerici e stringa, ma sono raramente usati.
   * Constant vs Computed Members: I membri possono essere costanti (valore calcolabile a compile-time) o calcolati (valore determinato a runtime). I membri calcolati pongono restrizioni sull'auto-incremento dei membri successivi.
   * const enums: Vengono completamente rimossi durante la compilazione e i loro valori sono inlinati nel codice JS risultante, offrendo un vantaggio prestazionale ma con alcune limitazioni (es. no membri calcolati, potenziali problemi con isolatedModules).
     const enum Stato { Attivo = 1, Inattivo = 0 }
let statoCorrente = Stato.Attivo; // Nel JS generato, questo diventa semplicemente '1'

     
     Sebbene utili, gli enum generano codice JavaScript runtime, a differenza dei tipi unione letterali (type Status = 'loading' | 'success') che esistono solo a compile-time. Per questo motivo, alcuni preferiscono usare unioni letterali al posto degli enum.
6. Moduli ES6 in TypeScript
TypeScript adotta pienamente la sintassi dei moduli ECMAScript 6 (ESM) per organizzare il codice in file separati e riutilizzabili.
 * (a) Sintassi import/export:
   * Named Exports: Esporta membri specifici usando export { nome1, nome2 } o export const/function/class nome....
   * Named Imports: Importa membri specifici usando import { nome1, nome2 } from './modulo'.
   * Default Export: Esporta un singolo valore predefinito usando export default....
   * Default Import: Importa il valore predefinito usando import nomeDefault from './modulo'.
   * Namespace Import: Importa tutti i membri esportati in un oggetto namespace usando import * as nomeNamespace from './modulo'.
   * Re-exporting: Esporta membri da un altro modulo usando export { nome } from './altroModulo' o export * from './altroModulo'.
 * (b) Type-Only Imports/Exports:
   Per importare o esportare solo tipi (interfacce, type alias) che devono essere rimossi dal codice JavaScript generato, si usa import type o export type, oppure il modificatore type su singoli elementi importati/esportati. Questo garantisce l'elisione e chiarisce l'intento.
   import type { TipoUtente } from './tipi';
import { funzioneValore, type InterfacciaUtente } from './utilita';

export type { Configurazione };

 * (c) export = e import = require():
   Sintassi specifica di TypeScript per interoperabilità con moduli CommonJS che usano module.exports =.... export = esporta un singolo valore. import Nome = require('./modulo') importa tale valore. Meno comune in progetti moderni che usano ESM.
 * (d) Configurazione (module, moduleResolution):
   Il file tsconfig.json è cruciale per definire come TypeScript gestisce i moduli:
   * module: Specifica il formato del modulo generato (es. CommonJS, ES2015, ES2020, ES2022, ESNext, Node16, NodeNext). Node16/NodeNext sono raccomandati per progetti Node.js moderni in quanto gestiscono l'interoperabilità CJS/ESM basata su package.json e estensioni file (.mts, .cts).
   * moduleResolution: Definisce l'algoritmo per risolvere i percorsi dei moduli (es. Node, Node16, NodeNext, Bundler, Classic). Node16/NodeNext o Bundler sono generalmente preferiti per progetti moderni.
     La corretta configurazione di queste opzioni è essenziale per garantire che gli import funzionino correttamente sia in fase di compilazione (per i tipi) sia a runtime (per il codice JavaScript).
7. Decorators
I Decorators forniscono un modo per aggiungere annotazioni e meta-programmazione a classi e ai loro membri.
 * (a) Concetto e Sintassi:
   Un decorator è una dichiarazione speciale che inizia con @ seguito da un'espressione (es. @decoratore). Questa espressione deve valutare a una funzione che viene chiamata a runtime (o design time per i nuovi decorator) con informazioni sull'elemento decorato.
 * (b) Decorator Sperimentali vs Stage 3:
   * Sperimentali: La versione originale supportata da TypeScript, richiede il flag --experimentalDecorators nel tsconfig.json. Hanno una certa sintassi e set di argomenti per tipo di decorator. Sono ampiamente usati in framework come Angular e NestJS.
   * Stage 3 (da TS 5.0): Allineati con la proposta ECMAScript Stage 3. Non richiedono flag (ma --experimentalDecorators abilita ancora la vecchia versione). Hanno una sintassi e argomenti leggermente diversi (es. l'oggetto context), non supportano i decorator di parametro e non sono compatibili con emitDecoratorMetadata.
 * (c) Tipi di Decorator (Sperimentali):
   * Class Decorator (@sealed): Applicato al costruttore della classe. Riceve il costruttore come argomento. Può restituire un nuovo costruttore per sostituire quello originale.
   * Method Decorator (@enumerable(false)): Applicato al Property Descriptor del metodo. Riceve target (prototipo o costruttore), propertyKey (nome metodo), descriptor. Può modificare o sostituire il descrittore.
   * Accessor Decorator (@configurable(false)): Simile al method decorator, ma applicato a get o set. Si applica solo al primo accessor definito.
   * Property Decorator (@format("...")): Applicato alla proprietà. Riceve target e propertyKey. Non riceve il descrittore e non può modificare direttamente la proprietà; usato principalmente per metadati.
   * Parameter Decorator (@required): Applicato a un parametro di costruttore o metodo. Riceve target, propertyKey, parameterIndex. Usato solo per osservare che un parametro è stato dichiarato.
 * (d) Casi d'Uso: Aggiungere metadati (es. per reflection, validazione, routing), Aspect-Oriented Programming (AOP) (es. logging, caching), modifica o sostituzione di definizioni di classi/metodi.
8. File di Dichiarazione (.d.ts)
I file di dichiarazione sono fondamentali per l'interoperabilità di TypeScript con JavaScript.
 * (a) Scopo: Contengono solo informazioni sui tipi (interfacce, tipi, firme di funzioni, classi, ecc.) senza alcuna implementazione. Permettono al compilatore TypeScript di comprendere la "forma" di codice JavaScript esistente, librerie esterne o API native dell'ambiente (come il DOM).
 * (b) Come Scriverli (declare): Si usa la parola chiave declare per indicare al compilatore che una variabile, funzione, classe, interfaccia, namespace, o modulo esiste altrove (nel codice JavaScript).
   // Esempio my-lib.d.ts
declare namespace myLib {
  function makeGreeting(s: string): string;
  let numberOfGreetings: number;
}
declare function globalGreet(message: string): void;
declare const PI: number;
declare class Greeter {
  constructor(greeting: string);
  showGreeting(): void;
}
declare module "untyped-module"; // Dichiara un modulo senza tipi specifici

 * (c) Utilizzo con DefinitelyTyped (@types): TypeScript cerca automaticamente i tipi in tre modi principali :
   * Librerie Built-in: File lib.*.d.ts forniti con TypeScript per API standard JS e DOM.
   * Tipi Bundled: File .d.ts inclusi direttamente nei pacchetti npm delle librerie.
   * DefinitelyTyped: Un vasto repository gestito dalla community contenente file .d.ts per migliaia di librerie JS. Questi vengono pubblicati su npm sotto lo scope @types (es. npm install --save-dev @types/lodash). TypeScript li trova automaticamente in node_modules/@types.
9. Utility Types Personalizzati
Oltre ai tipi di utilità integrati (Partial, Required, Readonly, Pick, Omit, Record, Exclude, Extract, NonNullable, ReturnType, InstanceType, Parameters, Awaited, ecc. ), è possibile creare tipi di utilità personalizzati usando le funzionalità avanzate di TypeScript come tipi mappati, condizionali e infer.
 * (a) Esempi:
   * Mutable<T>: Rimuove readonly da tutte le proprietà di T.
     type Mutable<Type> = {
  -readonly: Type[Property];
};

   * DeepPartial<T>: Rende opzionali tutte le proprietà di T, ricorsivamente. (Implementazione più complessa, non mostrata nei snippet ma concettualmente fattibile).
   * PromiseType<T>: Estrae il tipo risolto da una Promise T.
     type PromiseType<T> = T extends Promise<infer U>? U : never;

   * FunctionKeys<T>: Estrae le chiavi di T che sono funzioni.
     type FunctionKeys<T> = {
 : T[K] extends Function? K : never;
};

     (Variante basata su )
   * Brand<T, U>: Crea tipi nominali/opachi per distinguere tipi strutturalmente identici.
     type Brand<T, U> = T & { __brand: U };
type UserId = Brand<string, "UserId">;
type PostId = Brand<string, "PostId">;

 * (b) Utilità: I tipi di utilità personalizzati permettono di creare astrazioni riutilizzabili a livello di tipo, riducendo la duplicazione, migliorando la leggibilità e incapsulando logiche di tipo complesse.
10. Tipi Ricorsivi
I tipi ricorsivi sono tipi che fanno riferimento a se stessi nella loro definizione. Sono essenziali per modellare strutture dati come alberi, liste concatenate o formati come JSON.
 * (a) Definizione: Da TypeScript 3.7, i type alias possono fare riferimento a se stessi direttamente.
   // Esempio: Struttura ad albero
type TreeNode<T> = {
  value: T;
  children?: TreeNode<T>; // Riferimento ricorsivo
};

// Esempio: JSON
type Json =

| string
| number
| boolean
| null
| Json // Riferimento ricorsivo in array
| { [key: string]: Json }; // Riferimento ricorsivo in oggetto
```

 * (b) Considerazioni: Bisogna fare attenzione a non creare tipi infiniti. Spesso si usano proprietà opzionali (?) o tipi unione con un caso base (es. null) per terminare la ricorsione. Tipi ricorsivi molto profondi possono impattare le performance del compilatore.
V. Best Practice e Pattern di Design
Scrivere codice TypeScript efficace va oltre la semplice conoscenza della sintassi. Questa sezione esplora le linee guida e i pattern per creare codice pulito, manutenibile e scalabile.
1. Linee Guida per Codice Pulito e Manutenibile
 * (a) Configurazione tsconfig.json: Utilizzare un file tsconfig.json ben configurato è fondamentale. Abilitare la modalità strict ("strict": true) è altamente raccomandato per nuovi progetti, in quanto attiva una serie di controlli rigorosi (noImplicitAny, strictNullChecks, ecc.) che migliorano la sicurezza e la qualità del codice. Configurare correttamente target, module, moduleResolution, outDir, rootDir in base alle esigenze del progetto e dell'ambiente di destinazione.
 * (b) Linting e Formatting (ESLint, Prettier): Utilizzare strumenti come ESLint (con plugin specifici per TypeScript come @typescript-eslint) e Prettier per applicare automaticamente uno stile di codice consistente e individuare potenziali problemi. Questo migliora la leggibilità e facilita la collaborazione. Molti team adottano guide di stile consolidate come quelle di Google (-) o Airbnb ().
 * (c) Principi Generali di Clean Code:
   * Nomi Descrittivi: Usare nomi significativi e consistenti per variabili, funzioni, classi, tipi, ecc. (convenzioni comuni: camelCase per variabili/funzioni, PascalCase per tipi/classi/enum).
   * Evitare any: Usare any il meno possibile; preferire tipi specifici o unknown.
   * Immutabilità: Preferire l'immutabilità usando const per le variabili e readonly per le proprietà degli oggetti/array ove possibile.
   * Modularità: Organizzare il codice in moduli coesi per separare le responsabilità. Organizzare per feature piuttosto che per tipo di file.
   * Funzioni Pure: Scrivere funzioni che non abbiano effetti collaterali e restituiscano sempre lo stesso output per lo stesso input, quando possibile.
   * DRY (Don't Repeat Yourself): Evitare la duplicazione del codice usando funzioni, classi, generics e utility types.
   * Documentazione: Usare commenti JSDoc per documentare API pubbliche, tipi complessi e logiche non ovvie.
2. Pattern di Design in TypeScript
I classici pattern di design del software possono essere implementati efficacemente in TypeScript, sfruttando le sue funzionalità OOP e di tipizzazione.
 * (a) Esempi Comuni:
   * Singleton: Assicura che una classe abbia una sola istanza e fornisce un punto di accesso globale. Si implementa tipicamente con un costruttore privato e un metodo statico getInstance().
     class DatabaseConnection {
  private static instance: DatabaseConnection;
  private constructor() { /*... init connection... */ }

  public static getInstance(): DatabaseConnection {
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new DatabaseConnection();
    }
    return DatabaseConnection.instance;
  }
  //... metodi per query...
}
const dbConn = DatabaseConnection.getInstance();

   * Factory Method: Definisce un'interfaccia per creare un oggetto, ma lascia che siano le sottoclassi a decidere quale classe concreta istanziare. Usa spesso una classe astratta Creator con un metodo astratto factoryMethod() e classi ConcreteCreator che lo implementano.
     interface Prodotto { operazione(): string; }
class ProdottoConcretoA implements Prodotto { operazione = () => '{Risultato Prodotto A}'; }
class ProdottoConcretoB implements Prodotto { operazione = () => '{Risultato Prodotto B}'; }

abstract class Creator {
  public abstract factoryMethod(): Prodotto;
  public qualcheOperazione(): string {
    const prodotto = this.factoryMethod();
    return `Creator: Lavorando con ${prodotto.operazione()}`;
  }
}
class ConcreteCreatorA extends Creator { factoryMethod = () => new ProdottoConcretoA(); }
class ConcreteCreatorB extends Creator { factoryMethod = () => new ProdottoConcretoB(); }

const creatorA = new ConcreteCreatorA();
console.log(creatorA.qualcheOperazione());

   * Observer: Definisce una dipendenza uno-a-molti tra oggetti, in modo che quando un oggetto (Subject/Observable) cambia stato, tutti i suoi dipendenti (Observers/Subscribers) vengono notificati automaticamente. Richiede interfacce Subject (con metodi attach, detach, notify) e Observer (con un metodo update).
     interface Observer { update(subject: Subject): void; }
interface Subject { attach(observer: Observer): void; detach(observer: Observer): void; notify(): void; }

class ConcreteSubject implements Subject {
  public state: number = 0;
  private observers: Observer =;
  // implementa attach, detach, notify...
  public businessLogic(): void {
    this.state = Math.random();
    this.notify();
  }
}
class ConcreteObserverA implements Observer {
  public update(subject: Subject): void {
    if ((subject as ConcreteSubject).state < 0.5) { console.log('ObserverA reagisce'); }
  }
}
//... uso...
const subj = new ConcreteSubject();
const obsA = new ConcreteObserverA();
subj.attach(obsA);
subj.businessLogic();

 * (b) Applicazione: I pattern non vanno applicati ciecamente, ma scelti per risolvere problemi specifici di progettazione (es. gestione delle dipendenze, creazione di oggetti, gestione degli eventi). TypeScript, con interfacce, classi astratte, modificatori di accesso e generics, fornisce gli strumenti per implementare questi pattern in modo robusto e type-safe.
| Pattern | Concetto Chiave | Implementazione TS (Esempio) | Beneficio Chiave in TS | Snippets |
|---|---|---|---|---|
| Singleton | Garantisce una singola istanza di una classe, accesso globale. | Costruttore private, metodo static getInstance(). | Controllo dell'istanza unica garantito dal costruttore privato. |  |
| Factory Method | Definisce interfaccia per creare oggetti, delega istanziazione a sottoclassi. | Classe astratta Creator con abstract factoryMethod(), ConcreteCreators. | Decoupling tra client e classi concrete dei prodotti, tipi di ritorno verificati. |  |
| Observer | Meccanismo di sottoscrizione per notificare cambiamenti di stato. | Interfacce Subject (attach, detach, notify) e Observer (update), classi concrete. | Relazioni Subject-Observer tipizzate, notifiche sicure. |  |
3. Principi OOP e FP in TypeScript
TypeScript è un linguaggio multi-paradigma che supporta efficacemente sia la Programmazione Orientata agli Oggetti (OOP) sia la Programmazione Funzionale (FP).
 * (a) Supporto OOP:
   * Incapsulamento: Realizzato tramite modificatori di accesso (private, protected) che nascondono i dettagli interni di una classe.
   * Ereditarietà: Supportata tramite extends per creare gerarchie di classi e riutilizzare codice.
   * Polimorfismo: Ottenuto tramite ereditarietà (override di metodi) e implementazione di interfacce. Generics e function overloading contribuiscono anche al polimorfismo (ad-hoc). TypeScript verifica la compatibilità strutturale (duck typing) ma l'implementazione di interfacce (implements) fornisce un modo esplicito per definire contratti.
 * (b) Supporto FP:
   * Immutabilità: Incoraggiata e supportata tramite const per le variabili e il modificatore readonly per le proprietà di oggetti e array (Readonly<T>, ReadonlyArray<T>, as const). L'immutabilità previene effetti collaterali e semplifica il ragionamento sul codice.
   * Funzioni Pure: Le annotazioni di tipo per parametri e valori di ritorno aiutano a definire e verificare la purezza delle funzioni (stesso input produce sempre stesso output, nessun side effect).
   * Funzioni come First-Class Citizens: TypeScript, come JavaScript, tratta le funzioni come valori che possono essere assegnati a variabili, passati come argomenti (Higher-Order Functions) e restituiti da altre funzioni, facilitando pattern FP come map, filter, reduce.
Il sistema di tipi di TypeScript rafforza entrambi i paradigmi, permettendo agli sviluppatori di scegliere l'approccio migliore o di combinarli in modo sicuro.
4. Tipizzazione dei Parametri this
Gestire correttamente il contesto this è una sfida comune in JavaScript. TypeScript offre un meccanismo per tipizzare this esplicitamente, migliorando la sicurezza.
 * (a) Il Problema di this: In JavaScript, il valore di this dipende da come una funzione viene chiamata, non da dove è definita (tranne per le arrow functions). Questo può portare a errori se una funzione che usa this viene chiamata nel contesto sbagliato (es. come callback).
 * (b) Arrow Functions: Le arrow function (=>) non hanno un proprio this; catturano il this del contesto lessicale circostante in cui sono state definite. Questo risolve molti problemi comuni legati a this nelle callback o nei metodi.
 * (c) Parametri this: TypeScript permette di dichiarare un tipo esplicito per this come primo parametro (fittizio) di una funzione o metodo.
   interface OggettoConMetodo {
  valore: number;
  metodo(this: OggettoConMetodo, incremento: number): void;
}

let obj: OggettoConMetodo = {
  valore: 10,
  metodo(incremento) {
    // 'this' qui è garantito essere di tipo OggettoConMetodo
    this.valore += incremento;
  }
};

obj.metodo(5); // OK, 'this' è 'obj'

let metodoStandalone = obj.metodo;
// metodoStandalone(3); // Errore: Il contesto 'this' di tipo 'void' non è assegnabile a 'this' di tipo 'OggettoConMetodo'.

   
   Questo parametro this è solo per il controllo statico del tipo e viene rimosso nel JavaScript compilato. Indica al compilatore quale tipo di oggetto ci si aspetta sia il contesto this quando la funzione viene chiamata.
 * (d) this: void: Si può usare this: void per dichiarare esplicitamente che una funzione non deve fare affidamento su un contesto this specifico. Utile per le callback che potrebbero essere chiamate con this impostato a undefined o window.
La tipizzazione esplicita di this è una potente funzionalità di TypeScript per prevenire errori comuni legati al contesto di esecuzione delle funzioni in JavaScript.
VI. TypeScript nell'Ecosistema
TypeScript si integra ampiamente con i più diffusi framework e strumenti di sviluppo.
1. Integrazione con Framework Frontend
 * React: Ottimo supporto tramite file .tsx che combinano TypeScript e JSX. Richiede configurazione jsx in tsconfig.json. Si possono tipizzare props (usando interface o type), state (useState<T>), context (createContext<T>), refs (useRef<T>), e children (React.ReactNode). Risorse come React+TypeScript Cheatsheets sono utili. React Native ha anche un eccellente supporto per TypeScript.
 * Angular: Costruito interamente in TypeScript, che è il linguaggio primario e raccomandato. La configurazione di TypeScript (tsconfig.json) è parte integrante dei progetti Angular CLI. Sfrutta ampiamente le funzionalità di TS come classi, interfacce e decorator.
 * Vue.js: Supporto TypeScript di prima classe. Si usa <script setup lang="ts"> nei Single-File Components (SFCs). defineProps<T>() e defineEmits<T>() permettono di tipizzare props ed eventi in modo conciso. Richiede configurazione IDE (es. Volar) per un'esperienza ottimale.
 * Remix: Supporta nativamente file .ts e .tsx. Richiede tsconfig.json e configurazione con Vite (plugin @remix-run/dev). Il type checking viene eseguito separatamente con tsc. Può essere integrato con backend Express basati su TS.
 * SvelteKit: Si abilita TypeScript durante la creazione del progetto (npm create svelte@latest). Si usa l'attributo lang="ts" nei tag <script> dei componenti Svelte. Richiede svelte-preprocess e tsconfig.json. Il controllo dei tipi avviene tramite svelte-check. Supporta import type per importare solo tipi.
2. Integrazione con Framework Backend (Node.js)
 * Node.js Generale: Si configura un progetto Node.js per TypeScript installando typescript, @types/node e creando un tsconfig.json (con opzioni appropriate per module, moduleResolution, target, outDir). Il codice TS viene compilato in JS (con tsc) e poi eseguito con node, oppure si usano runner come ts-node o tsx per l'esecuzione diretta durante lo sviluppo. È importante gestire correttamente i tipi per le API asincrone di Node.js (Promises) usando async/await e Promise<T>.
 * Express con TypeScript: Setup comune che prevede l'installazione di express, typescript, @types/node, @types/express. Si scrive il server Express in un file .ts, importando i tipi per Request, Response, Application da express. Si configura tsconfig.json e si usano script npm per compilare (tsc) ed eseguire (node dist/index.js o nodemon index.ts/ts-node-dev).
 * NestJS: Framework Node.js progressivo costruito su TypeScript, che ne sfrutta appieno le funzionalità (classi, decorator, interfacce, DI). Fornisce una struttura modulare e robusta per applicazioni backend scalabili. L'uso di TypeScript è predefinito e integrato nel workflow del framework tramite Nest CLI.
3. Sviluppo di Estensioni per VS Code con TypeScript
TypeScript è il linguaggio principale per lo sviluppo di estensioni VS Code.
 * (a) Struttura Base e API:
   * Il punto di ingresso è la funzione activate(context: vscode.ExtensionContext) esportata dal file principale (spesso src/extension.ts).
   * L'oggetto ExtensionContext (context) è fondamentale. Fornisce accesso a:
     * context.subscriptions: Un array di oggetti Disposable. È cruciale aggiungere qui tutte le risorse che necessitano di pulizia (registrazioni di comandi, listener di eventi, pannelli webview, ecc.) usando context.subscriptions.push(disposable). VS Code chiamerà automaticamente il metodo dispose() su ciascun elemento in questo array quando l'estensione viene disattivata, prevenendo memory leak.
     * API di Storage:
       * context.globalState (Memento): Archiviazione chiave-valore globale per l'estensione, persistente tra diverse aree di lavoro e sessioni di VS Code. Adatta per preferenze utente o stati che non dipendono dal progetto.
       * context.workspaceState (Memento): Archiviazione chiave-valore specifica dell'area di lavoro corrente. I dati persistono solo per quella specifica area di lavoro.
       * context.storageUri (Uri): Percorso di una directory locale specifica dell'area di lavoro, con accesso in lettura/scrittura. Utile per file grandi legati al workspace.
       * context.globalStorageUri (Uri): Percorso di una directory locale globale per l'estensione, con accesso in lettura/scrittura. Utile per file grandi accessibili da tutte le aree di lavoro.
       * context.secrets (SecretStorage): Archiviazione globale sicura (crittografata) per dati sensibili come token API o password. Non viene sincronizzata tra macchine.
     * Altre proprietà utili come extensionUri (percorso dell'estensione), logPath, ecc..
   * La funzione deactivate() (opzionale) viene chiamata prima che l'estensione venga disattivata e può essere usata per cleanup aggiuntivo non gestito tramite subscriptions.
 * (b) package.json:
   * File manifesto essenziale che descrive l'estensione.
   * Campi chiave: name, publisher, version, engines.vscode (compatibilità), main (punto di ingresso, es. ./out/extension.js), activationEvents, contributes.
   * activationEvents: Array di eventi che attivano l'estensione (lazy loading). Caricare un'estensione solo quando necessario migliora le performance di VS Code. Eventi comuni:
     * onCommand:commandId: Attiva all'esecuzione di un comando specifico.
     * onLanguage:languageId: Attiva all'apertura di un file di un linguaggio specifico (es. typescript).
     * onView:viewId: Attiva quando una vista specifica viene aperta/espansa.
     * workspaceContains:globPattern: Attiva se l'area di lavoro contiene file che corrispondono al pattern.
     * onStartupFinished: Attiva dopo l'avvio completo di VS Code.
     * *: Attiva all'avvio (usare con cautela per non impattare le performance).
   * contributes: Oggetto dove l'estensione dichiara i suoi contributi all'UI di VS Code, come comandi, menu, viste, configurazioni, keybindings, ecc.. Ad esempio, per rendere un comando visibile nella Command Palette:
     "contributes": {
  "commands": [
    {
      "command": "miaEstensione.comandoEsempio",
      "title": "Esegui Comando Esempio"
    }
  ]
}

 * (c) Esempi Concreti (ExtensionContext, package.json):
   * Uso di context.subscriptions:
     // In extension.ts
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  console.log('Estensione attivata!');

  // Registra un comando
  let disposableCommand = vscode.commands.registerCommand('miaEstensione.saluta', () => {
    vscode.window.showInformationMessage('Ciao da Mia Estensione!');
  });

  // Aggiungi il comando disposable alle subscriptions
  // Verrà chiamato dispose() automaticamente alla disattivazione
  context.subscriptions.push(disposableCommand);

  // Registra un listener di eventi (esempio)
  let disposableListener = vscode.window.onDidChangeActiveTextEditor(editor => {
    if (editor) {
      console.log(`Editor attivo cambiato: ${editor.document.fileName}`);
    }
  });
  context.subscriptions.push(disposableListener);
}

export function deactivate() {
  console.log('Estensione disattivata.');
  // Cleanup aggiuntivo se necessario
}

   * Uso di context.globalState:
     // In extension.ts (dentro activate o un comando)
export function activate(context: vscode.ExtensionContext) {
  //...
  // Legge un valore (restituisce undefined se non esiste)
  const contatoreAvvii: number | undefined = context.globalState.get<number>('contatoreAvvii');
  const nuovoContatore = (contatoreAvvii |

| 0) + 1;
// Scrive/Aggiorna un valore
context.globalState.update('contatoreAvvii', nuovoContatore)
.then(() => {
console.log(Estensione avviata ${nuovoContatore} volte.);
});
// Per sincronizzare questo stato tra macchine (se Settings Sync è attivo)
context.globalState.setKeysForSync(['contatoreAvvii']); // 
//...
}
[span_915](start_span)[span_915](end_span)[span_916](start_span)[span_916](end_span)[span_917](start_span)[span_917](end_span)[span_918](start_span)[span_918](end_span)[span_919](start_span)[span_919](end_span) *   **Esempio `package.json` (`activationEvents`, `contributes`):**json
{
"name": "mia-estensione",
"displayName": "Mia Estensione Esempio",
"version": "0.0.1",
"publisher": "tuoNome",
"engines": {
"vscode": "^1.80.0" // Specifica versione VS Code minima
},
"main": "./out/extension.js", // Punto di ingresso compilato
"activationEvents":,
"contributes": {
"commands":,
"keybindings":,
"menus": { // Esempio di aggiunta al menu contestuale dell'editor
"editor/context": [
{
"when": "editorLangId == typescript",
"command": "miaEstensione.saluta",
"group": "navigation"
}
]
}
}
//... altre sezioni come dependencies, devDependencies...
}
```

 * (d) Sicurezza delle Estensioni VS Code:
   Le estensioni VS Code girano in un processo "extension host" che ha gli stessi permessi dell'istanza principale di VS Code. Questo significa che un'estensione può, in linea di principio, leggere/scrivere file, eseguire processi esterni e fare richieste di rete. Questo modello basato sulla fiducia ("trust-based model")  contrasta con modelli a permessi più granulari come quelli dei browser o di Android.
   * Rischi: Estensioni malevole o vulnerabili possono esporre a rischi come furto di dati (codice sorgente, credenziali), esecuzione di codice arbitrario (ACE), o degrado della sicurezza dell'ambiente di sviluppo. Problemi comuni includono typosquatting nel marketplace, dipendenze malevole, comunicazione con IP hardcoded, esecuzione di binari sconosciuti. Anche estensioni apparentemente innocue (es. temi) sono state compromesse.
   * Misure di VS Code:
     * Marketplace Protections: Scansione malware, rilevamento dinamico, verifica degli editori (checkmark blu), monitoraggio di uso anomalo, blocco di name squatting, block list per estensioni malevole (con disinstallazione automatica), verifica della firma dell'estensione.
     * Workspace Trust: Funzionalità che esegue VS Code in "Restricted Mode" quando si apre una cartella/workspace non fidato. In questa modalità, funzionalità potenzialmente rischiose come task, debugging, alcune impostazioni di workspace, ed estensioni che non hanno optato per il supporto limitato sono disabilitate o richiedono conferma esplicita. Gli autori di estensioni possono dichiarare supporto limitato o nullo per la Restricted Mode.
     * Publisher Trust: Da VS Code 1.97, viene chiesto all'utente di confermare la fiducia verso un editore terzo la prima volta che si installa una sua estensione.
     * Sandbox (Renderer Process): VS Code ha implementato il sandboxing per il processo renderer (che gestisce l'UI) per limitare l'impatto di vulnerabilità in quella parte dell'architettura, separando l'accesso alle API Node.js. Tuttavia, l'extension host stesso non opera in una sandbox così restrittiva.
   * Best Practice per Sviluppatori: Seguire il principio del privilegio minimo (least privilege) quando si usano le API di VS Code. Validare e sanificare sempre l'input non fidato (vedi sezione successiva su Webview). Essere cauti con le dipendenze.
4. Librerie di Validazione Runtime (Zod, io-ts)
Il sistema di tipi di TypeScript verifica i tipi solo in fase di compilazione. Quando si ricevono dati da fonti esterne (API, input utente, file system, messaggi da Webview) a runtime, questi dati non hanno garanzie di tipo intrinseche. È quindi essenziale validare questi dati a runtime per garantire che corrispondano ai tipi attesi da TypeScript e prevenire errori o vulnerabilità.
 * (a) Perché sono Importanti: Servono a colmare il divario tra la sicurezza statica di TypeScript e la natura dinamica dei dati esterni. Verificano che i dati ricevuti a runtime abbiano la struttura e i tipi corretti prima di utilizzarli nel codice tipizzato.
 * (b) Zod:
   * Libreria "TypeScript-first" per la dichiarazione e validazione di schemi.
   * Sintassi Dichiarativa: Si definiscono schemi usando funzioni come z.string(), z.number(), z.object({...}), z.array(...), z.union(...), z.discriminatedUnion(...), ecc..
   * Inferenza del Tipo: Zod può inferire automaticamente il tipo TypeScript statico dallo schema definito (z.infer<typeof MioSchema>), eliminando la necessità di dichiarare tipi e schemi separatamente e garantendo la loro sincronia.
   * Parsing: Usa .parse(data) (lancia eccezione in caso di errore) o .safeParse(data) (restituisce un oggetto con success: boolean e data o error) per validare i dati.
   * Custom Validation: Supporta validazioni personalizzate tramite .refine().
   * Esempio:
     import { z } from 'zod';

// Definizione dello schema
const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
  email: z.string().email(),
  isAdmin: z.boolean().optional(),
});

// Inferenza del tipo TypeScript
type User = z.infer<typeof UserSchema>;

function processUserData(data: unknown) {
  const validationResult = UserSchema.safeParse(data);
  if (validationResult.success) {
    const user: User = validationResult.data;
    // Ora 'user' è garantito essere di tipo User
    console.log(`Utente valido: ${user.name}`);
  } else {
    console.error("Dati utente non validi:", validationResult.error.errors);
  }
}

processUserData({ id: "...", name: "Test", email: "test@example.com" }); // OK
processUserData({ id: "123", name: "" }); // Errore di validazione

 * (c) io-ts:
   * Libreria per la decodifica/codifica e validazione di tipi runtime, basata su concetti di programmazione funzionale (usa fp-ts).
   * Codec: Definisce "codec" (es. t.string, t.number, t.type({...}), t.array(...), t.union(...)) che rappresentano tipi runtime.
   * Decoding: Usa il metodo .decode(data) che restituisce un tipo Either<Errors, A> da fp-ts. Right(value) indica successo, Left(errors) indica fallimento con dettagli sugli errori.
   * Inferenza del Tipo: Si può estrarre il tipo statico da un codec usando t.TypeOf<typeof MioCodec>.
   * Esempio:
     import * as t from 'io-ts';
import { isRight } from 'fp-ts/lib/Either';
import { PathReporter } from 'io-ts/lib/PathReporter'; // Per report errori leggibili

// Definizione del codec
const UserCodec = t.type({
  userId: t.number,
  name: t.string,
});

// Estrazione del tipo statico
type User = t.TypeOf<typeof UserCodec>;

function processUserDataIO(data: unknown) {
  const validationResult = UserCodec.decode(data);

  if (isRight(validationResult)) {
    const user: User = validationResult.right;
    // Ora 'user' è garantito essere di tipo User
    console.log(`Utente valido (io-ts): ${user.name}`);
  } else {
    console.error("Dati utente non validi (io-ts):", PathReporter.report(validationResult));
  }
}

processUserDataIO({ userId: 123, name: "Test" }); // OK
processUserDataIO({ userId: "abc", name: "Test" }); // Errore di validazione

Entrambe le librerie sono potenti strumenti per garantire che i dati provenienti da fonti non fidate siano conformi ai tipi attesi dal codice TypeScript prima di essere processati.
5. Sicurezza nella Comunicazione (es. Webview)
Le Webview in VS Code permettono alle estensioni di creare interfacce utente HTML/CSS/JS personalizzate, ma introducono anche considerazioni di sicurezza specifiche.
 * (a) Sandbox e Rischi: Le Webview girano in un processo separato e sandboxed, senza accesso diretto alle API Node.js o al file system locale, a differenza dell'extension host. Tuttavia, possono comunicare con l'estensione tramite postMessage. Se un attaccante riesce a eseguire codice malevolo nella Webview (es. tramite XSS), potrebbe potenzialmente inviare messaggi malevoli all'estensione per indurla a compiere azioni dannose (es. leggere file sensibili, eseguire comandi).
 * (b) Content Security Policy (CSP): È fondamentale definire una CSP restrittiva per la Webview per mitigare i rischi di XSS. La CSP viene aggiunta come meta tag nell'HTML della Webview.
   * Best Practices:
     * Iniziare con una policy molto restrittiva: default-src 'none';.
     * Abilitare le sorgenti solo se strettamente necessario per direttive specifiche (script-src, style-src, img-src, connect-src, ecc.).
     * Evitare unsafe-inline e unsafe-eval per script-src.
     * Usare nonces (numeri casuali usati una sola volta, generati per ogni caricamento della webview e inseriti sia nella CSP che negli attributi nonce degli script/style tags) o hashes ('sha256-...') per permettere l'esecuzione solo di script e stili specifici e fidati. Il nonce deve essere crittograficamente robusto [
